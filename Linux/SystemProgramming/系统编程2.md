# 系统编程2

### 4.exec函数族

fork创建子进程后**执行的是和父进程相同的程序**（但有可能执行不同的代码分支），子进程往往要调用一种 exec 函数来执行另一个程序。

当进程调用一种 exec 函数时，该进程的**用户空间代码和数据完全被新程序替换**，从新程序的启动例程开始执行。调用 exec 并不创建进程，所以调用 exec 前后该进程id **并未改变**。

将当前进程的.text、.data替换为所要加载的程序的.data、.text，然后让进程从新的.text第一条指令开始执行，但进程ID不变，**换核不换壳**！

有 6 种以exec开头的函数，统称exec函数：

1. int execl(const char* path, const char* arg, ...)
2. int execlp(const char* file, const char* arg, ...)
3. int execle(const char* path, const char* arg, ..., char* const envp[]) // e-加载环境变量env
4. int execlv(const char* path, char* const argv[])
5. int execvp(const char* file, char* const argv[]) // p-加载进程
   - 加载一个进程，使用自定义环境变量env
   - 变参形式：①... ②argv[] (main函数也是变参函数，形式上等同于 int main(int argc, char* argv0, ..))
   - 变参终止条件：①NULL结尾 ②指定固定参数
   - execvp 与 execlp 参数形式不同，原理一致
6. int execve(const char* path, char* const argv[], char* const envp[])

#### 4.1. execl函数



execlp.c代码

```c
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
int main(){
        pid_t pid;
        pid = fork();
        if(pid == -1){
            perror("fork error!");
            exit(1);
        }else if(pid > 0){
            printf("=======>I'm parent<=========\n");
        }else{ // 子进程
            execlp("/bin/ls", "ls", "-l", NULL); // 相当于让子进程执行 ls -l的命令, NULL是结束标记
            // execl("./自定义可执行文件路径", "可执行文件", NULL);
        }
        return 0;
}
```

![image-20210517104353546](系统编程2.assets/image-20210517104353546.png)

跟ls -l效果是一样的

![image-20210517104433530](系统编程2.assets/image-20210517104433530.png)

exec_ps.c代码，实现将ps aux > ps.out 的功能（将ps的屏幕输出放到文件中，也叫作重定向）

```c
#include<stdio.h>
#include<fcntl.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

int main(){
        // 打开文件
        int fd;
        fd = open("ps.out", O_WRONLY|O_CREAT|O_TRUNC, 0644);
        // 判断打开是否成功
        if(fd < 0){
                perror("open ps.out error!\n");
                exit(1);
        }
        // 重定向
        dup2(fd, STDOUT_FILENO); // STDOUT --> fd -> ps.out
        
    	execlp("ps", "ps", "aux", NULL);
    	perror("execlp error!");
    	exit(1);
        
    	return 0;
}

```

#### 4.2.一般规律

exec函数一旦调用成功即执行新的程序，不返回。**只有失败才返回，错误值 -1**。所以通常我们直接在 exec函数调用后用perror() 和 exit()，无需if判断

l -- list -- 命令行参数

p -- path -- 搜索file时使用path变量

v -- vector -- 使用命令行 参数数组

e -- environment -- 使用环境变量数组，不使用进程原有的环境变量，设置新加载程序运行的环境变量



### 5.回收子进程

​	**孤儿进程**：父进程先于子进程结束，则子进程成为孤儿，这些孤儿由init进程领养，由init进程回收释放。

​	**僵尸进程**：进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie)进程。值得注意的是，僵尸进程是不能用kill命令清除的。因为kill是用来终止进程的，**而僵尸进程已经终止**（但未回收）。

#### 5.1.wait函数

​	一个进程在终止时会关闭所有的文件描述符，释放在用户空间分配的内存，**但它的PCB还保留着，内核在其中保存了一些信息**：如果是**正常终止**则保存着退出状态；如果是**异常终止**则保存着**导致该进程终止的信号是哪个**。这个进程的父进程可以调用wait 或 waitpid获取这些信息，然后彻底清除这个进程。我们知道一个进程的退出状态可以在shell中用特殊变量 $? 查看，因为 shell 是它的父进程，**当它终止时shell调用wait 或 waitpid得到它的退出状态**，同时彻底清除这个进程。

​	**父进程调用wait函数可以回收子进程终止信息。该函数有3个功能**：

1. 阻塞等待子进程退出
2. 回收子进程残留资源
3. 获取子进程结束状态（子进程为什么退出了）

pid_t wait(int* status)；返回值：成功--清理掉的子进程ID；失败-- -1（没有子进程）

​	当进程终止时，操作系统的隐式回收机制为：

1. 关闭所有文件描述符
2. 释放用户空间分配的内存；内核的PCB仍存在。其中保存该进程的退出状态。（正常终止->退出值；异常终止 ->终止信号）

​    可使用wait函数**传出参数status来保存进程的退出状态**。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：

1. WIFEXITED(status) != 0 --> 进程正常结束

   ​	WEXITSTATUS(status) --> 如上宏为真，即进程正常退出，使用这个宏 --> 获得进程退出状态（exit的参数）

2. WIFSIGNALED(status) != 0 --> 进程异常终止

   ​	WTERMSIG(status) --> 如上宏为真，即进程异常退出，使用这个宏 --> 获得使进程异常终止的那个信号的编号

   3.略





```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/wait.h>

int main(void){
        pid_t pid, wpid;
    	int status; // 子进程退出的信息
        pid = fork();

        if(pid == 0){ // 子进程
            printf("=======child, my parent = %d, going to sleep 10s\n", getppid());
            sleep(30);
            printf("=================child die======================\n");
            exit(100);
        }else if(pid > 0){ // 父进程
            wpid = wait(&status); // 回收子进程，并将信息放入status
            if(wpid == -1){ // 回收失败返回 -1
                perror("wait error");
                exit(1);
            }
            if(WIFEXITED(status)){ // 子进程正常退出
                printf("child exit with %d\n", WEXITSTATUS(status));
            }
            if(WIFSIGNALED(status)){ // 子进程异常退出
                printf("child killed by %d\n", WTERMSIG(status)); //返回令进程终止的信号
            }
            while(1){
                printf("I‘m parent, pid = %d, myson = %d\n", getpid(), pid);
                sleep(1);
            }
        }else{
            perror("fork error!");
            exit(1);
        }
        return 0;
}

```

运行./zoom_wait

![image-20210517230330867](系统编程2.assets/image-20210517230330867.png)

然后在子进程未正常结束前，人为终止;

![image-20210517230125874](系统编程2.assets/image-20210517230125874.png)

产生异常信息。可以看到，返回令进程终止的信号 ==> 9

![image-20210517230414866](系统编程2.assets/image-20210517230414866.png)

