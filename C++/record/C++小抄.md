# C++小抄

## 内存管理

### 1.类的大小

假如有一个类A，里面没有任何成员，那么它的大小`sizeof(A)=1`，因为C++标准不允许大小为0的类，这是因为：

1. 使用`new`来动态为类对象分配一个空间的时候，不能分配为0的大小。
2. 避免使用除以`sizeof(A)`（为0）的情况

所以要给空类分配一个字节的大小。

假如现在有一个B类继承A类，且B类不为空，那么`sizeof(B)`就是**仅仅计算B内成员的大小，而继承的A的大小为0。**



空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。

有**虚函数的类对象**中都有一个虚函数表指针 __vptr，其大小是4字节

```c++
class A { virtual Fun(){} };
int main(){
     cout<<sizeof(A)<<endl;// 输出 4(32位机器)/8(64位机器);
     A a; 
     cout<<sizeof(a)<<endl;// 输出 4(32位机器)/8(64位机器);
     return 0; 
}
```



静态成员存放在**静态存储区**，不占用类的大小, 普通函数也不占用类大小

```c++
class A { static int a; };
int main(){
     cout<<sizeof(A)<<endl;// 输出 1;
     A a; 
     cout<<sizeof(a)<<endl;// 输出 1;
     return 0; 
}
```

类对象的大小受哪些因素影响？

- 普通的非静态成员，根据类型大小判断
- 结构对齐而分配的大小
- 非静态成员不占用内存大小，成员函数也不占用内存大小
- 如果是派生类，继承基类的那一部分也会占用一定空间
- 类对象有虚函数的话，会在类对象中插入虚函数指针，会占用一个指针大小

### 2.C++的内存管理

在C++中，内存分成5个区，他们分别是堆、栈、全局/静态存储区和常量存储区和代码区

- **栈**，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
- **堆**，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
- **全局/静态存储区**，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。
- **常量存储区**，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。
- **代码区**，存放程序的二进制代码

### 3.类的数据成员和成员函数内存分布情况

一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的同时这些成员变量也就被定义了）

成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。（要是成员函数占用类的对象空间，**那么将是多么可怕的事情**：定义一次类对象就有成员函数占用一段空间。）

函数都是放在代码区，不占用内存，静态函数也不例外，不要一看到 **static** 这个单词就主观的认为是存放在全局数据区，那是不对的。



### 4.关于this指针你知道什么？

性质

- 类内指针
- 只能在非静态成员函数内使用，且只能调用非静态成员，不能在全局函数、静态函数中使用
- this指针只有在 成员函数 中才有定义，且存储位置会因编译器不同有不同存储位置

this指针是一个类内隐含指针，指向类所占内存的首地址，也可以显式的调用非静态成员，比如`return a`，可以写成`return this.a`(a为非静态成员)。如果返回类本身`return *this`

编译器会对this指针进行优化，传递速度较快。

**创建销毁：**this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：

```c++
A a;
a.func(10);//此处，编译器将会编译成：A::func(&a,10);
```



**存放位置：**this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。



## C++11新标准

### 1.哪些新特性

- nullptr代替NULL
- auto、decltype关键字推导类型
- 基于范围的for(auto& a:A)遍历
- 类、结构的初始化列表
- Lambda表达式（匿名函数）
- forward_list（单向链表）

### 2.auto\decltype

**auto**：编译器通过初始值来进行类型的推演，从而获得变量的类型。所以说auto定义的变量必须有初始值

```c++
//普通；类型
int a = 1, b = 3;
auto c = a + b;// c为int型
//const类型
const int i = 5;
auto j = i; // 变量i是顶层const, 会被忽略, 所以j的类型是int
auto k = &i; // 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*
const auto l = i; //如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt,需要显式

//引用和指针类型
int x = 2;
int& y = x;
auto z = y; //z是int型 不是int& 型!!!
auto& p1 = y; //p1是int&型,需要显式
auto p2 = &x; //p2是指针类型int*
```

**decltype**：如果希望从**表达式**中推断出要定义变量的类型，但却不想用表达式的值去初始化变量，可以使用(就是只使用类型，不使用内容)

它的作用是 选择并返回 操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却**不进行实际的计算表达式**的值

```c++
int func() {return 0};
//普通类型
decltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()

int a = 0;
decltype(a) b = 4; // a的类型是int, 所以b的类型也是int

//不论是顶层const还是底层const, decltype都会保留 
const int c = 3;
decltype(c) d = c; // d的类型和c是一样的, 都是顶层const

int e = 4;
const int* f = &e; // f是底层const
decltype(f) g = f; // g也是底层const

//引用与指针类型
//1. 如果表达式是引用类型, 那么decltype的类型也是引用
const int i = 3, &j = i;
decltype(j) k = 5; // k的类型是 const int&
//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:
int i = 3, &r = i;
decltype(r + 0) t = 5; // 此时是int类型
//3. 对指针的解引用操作 返回的是引用类型
int i = 3, j = 6, *p = &i;
decltype(*p) c = j; // c是int&类型, c和j绑定在一起
//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用
类型了
int i = 3;
decltype((i)) j = i; // 此时j的类型是int&类型, j和i绑定在了一起
```



### 3.nullptr\NULL

NULL是C语言中定义为(void*)，而在C++中则被定义为整数0

NULL有什么缺点？

> 在传入NULL参数时，会把NULL当做整数0来看，如果我们想**调用参数是指针**的函数，该怎么办
>
> 呢?nullptr在C++11被引入用于解决这一问题，nullptr可以**明确区分整型和指针类型**，不会与整型变量相混淆，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。

```c++
#include <iostream>
using namespace std;
void fun(char* p) {
 cout << "char*" << endl; 
}
void fun(int p) {
 cout << "int" << endl;
}
int main()
{
    fun(NULL); 
    return 0;
}
//输出结果：int
```

