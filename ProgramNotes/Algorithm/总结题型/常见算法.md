# 算法

## 排序算法         

### 1、冒泡算法

```c++
#include <iostream>
#include <vector>
#include <algorithm> 
#define Num 100 
using namespace std;

//产生随机数 
void rand_nums(vector<int> &temp)
{
    for (int i = 0; i < Num; ++i) temp.push_back(i + 1);
    random_shuffle(temp.begin(), temp.end());
}

void print(vector<int> &nums){
	for(int i = 0; i<nums.size(); i++){
		cout << nums[i] << " ";
		if((i+1)%10 == 0) cout << "\n";
	}
}

// 冒泡算法
void bubble_sort(vector<int> &nums){
	int flag = 1;
	for(int i=0; i<nums.size() && flag; i++){
		for(int j=nums.size()-1; j>i; j--){
			flag = 0; // 发生交换会置1
			if(nums[j] > nums[j-1]){
				swap(nums[j], nums[j-1]);
				flag = 1;
			}
		}
	}
}

int main(){
	vector<int> nums;
	rand_nums(nums);
	print(nums);
	cout << endl;
	bubble_sort(nums);
	print(nums);
	return 0;
} 
```



### 2、选择排序

```c++
#include <iostream>
#include <vector>
#include <algorithm> 
#define Num 100 
using namespace std;

//产生随机数 
void rand_nums(vector<int> &temp)
{
    for (int i = 0; i < Num; ++i) temp.push_back(i + 1);
    random_shuffle(temp.begin(), temp.end());
}

void print(vector<int> &nums){
	for(int i = 0; i<nums.size(); i++){
		cout << nums[i] << " ";
		if((i+1)%10 == 0) cout << "\n";
	}
}

// 选择排序 
void choose_sort(vector<int> &nums){
	for(int i = 0; i<nums.size(); i++){ //遍历每一个数 
		int maxIndex = i;
		for(int j = i+1; j<nums.size(); j++){ //找最大值的下标 
			if(nums[j] > nums[maxIndex]) maxIndex = j;
		}
		swap(nums[i], nums[maxIndex]); //将最大值交换到i的位置 ，完成了最大值选择到前面 
	}
}

int main(){
	vector<int> nums;
	rand_nums(nums);
	
	print(nums);
	cout << endl;
	
	choose_sort(nums);
	
	print(nums);
	return 0;
} 
```



### 3、插入排序

```c++
#include <iostream>
#include <vector>
#include <algorithm> 
#define Num 100 
using namespace std;

//产生随机数 
void rand_nums(vector<int> &temp)
{
    for (int i = 0; i < Num; ++i) temp.push_back(i + 1);
    random_shuffle(temp.begin(), temp.end());
}

void print(vector<int> &nums){
	for(int i = 0; i<nums.size(); i++){
		cout << nums[i] << " ";
		if((i+1)%10 == 0) cout << "\n";
	}
}

// 插入排序 
void insert_sort(vector<int> &nums){
	for(int i = 1; i<nums.size(); i++){
		for(int j = i-1; j>=0; j--){ // 将i之前的数都比较一遍，并把更大的数放到前面 
			if(nums[j+1] > nums[j]){
				swap(nums[j], nums[j+1]); 
			}
		}
	}
}

int main(){
	vector<int> nums;
	rand_nums(nums);
	
	print(nums);
	cout << endl;
	
	insert_sort(nums);
	print(nums);
	
	return 0;
} 
```



### 4、归并排序

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void mergeSort(vector<int>& nums, int l, int r);
void print(vector<int>& nums, int start, int end);
void merge(vector<int>& nums, int l, int mid, int r);

int main(){
    vector<int> nums = {4, 2, 1, 5, 9, 6, 7, 10, 3, 8};
    print(nums, 0, nums.size() - 1);
    mergeSort(nums, 0, nums.size() - 1);
    print(nums, 0, nums.size() - 1);
    return 0;
}

void merge(vector<int>& nums, int l, int mid, int r){ // 归并过程
    vector<int> help(r - l + 1); // 辅助数组
    int p1 = l, p2 = mid + 1; // 两个组：p1∈[l, mid]，p2∈[mid + 1, r]
    int i = 0; // i划过help数组的下标
    // 1.哪个小拷贝哪个
    while(p1 <= mid && p2 <= r){
        help[i++] = (nums[p1] <= nums[p2]) ? nums[p1++] : nums[p2++]; 
    }
    // 2.还有可能一个组没拷贝完，也要添加到help后面
    while(p1 <= mid) help[i++] = nums[p1++];
    while(p2 <= r) help[i++] = nums[p2++];
    // 3.拷贝回原数组
    for(int i = 0; i < help.size(); i++){
        nums[l + i] = help[i];
    }
}

// 归并排序
void mergeSort(vector<int>& nums, int l, int r){
    if(nums.size() < 2) return;
    if(l == r) return;
    int mid = l + (r - l) / 2;
    mergeSort(nums, l, mid); // 左段有序
    mergeSort(nums, mid + 1, r); // 右段有序
    merge(nums, l, mid, r); // 合并左右
}

void print(vector<int>& nums, int start, int end){
    if(start > end){
        cout << "index error" << endl;
        return;
    }
    cout << endl;
    for(int i = start; i <= end; i++){
        cout << nums[i] << '\t';
    }
    cout << endl;
}
```



### 5、快速排序

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void quickSort(vector<int>& nums, int l, int r);
void print(vector<int>& nums, int start, int end);

int main(){
    vector<int> nums = {4, 2, 1, 5, 9, 6, 7, 10, 3, 8};
    print(nums, 0, nums.size() - 1);
    quickSort(nums, 0, nums.size() - 1);
    print(nums, 0, nums.size() - 1);
    return 0;
}

// 快速排序
void quickSort(vector<int>& nums, int l, int r){
    if(l > r) return;
    int i = l, j = r;
    // 将 [l, r]与哨兵nums[l]大小相比进行划分，成两组
    while(i < j){
        while(i < j && nums[j] > nums[l]) j--; // 从右往左，大于哨兵nums[l]就j--
        while(i < j && nums[i] < nums[l]) i++; // 从左往右，小于哨兵nums[l]就i++
        swap(nums[i], nums[j]); // 此时nums[i] >= nums[l], nums[j] <= nums[l]
    }
    // 以i为分界线，将哨兵nums[l]放到分界线处
    swap(nums[l], nums[i]);
    // 以i为分界线，[l, i - 1]为小于nums[l], [i + 1, r]为大于nums[l]
    quickSort(nums, l, i - 1);
    quickSort(nums, i + 1, r);
}



void print(vector<int>& nums, int start, int end){
    if(start > end){
        cout << "index error" << endl;
        return;
    }
    cout << endl;
    for(int i = start; i <= end; i++){
        cout << nums[i] << '\t';
    }
    cout << endl;
}

```



### 6、堆排序

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void heapInsert(vector<int>& nums, int index);
void heapify(vector<int>& nums, int index, int heapSize);
void heapSort(vector<int>& nums);
void print(vector<int>& nums, int start, int end);

int main(){
    vector<int> nums = {4, 2, 1, 5, 9, 6, 7, 10, 3, 8};
    print(nums, 0, nums.size() - 1);
    heapSort(nums);
    print(nums, 0, nums.size() - 1);
    return 0;
}


void heapInsert(vector<int>& nums, int index){ // 调整成大根堆
   // 给你一个节点下标是index，那么它的父节点是 (index - 1) / 2
   // 这一部分就是将父节点 调节成 大根堆
   while(nums[index] > nums[(index - 1) / 2]){
       swap(nums[index], nums[(index - 1) / 2]);
       index = (index - 1) / 2;
   }
}

void heapify(vector<int>& nums, int index, int heapSize){
    int left = 2 * index + 1;
    while(left < heapSize){
        // 1.父节点index、左右孩子的最大值
        int largest = (left + 1 < heapSize && nums[left + 1] > nums[left]) ? left + 1 : left;
        largest = (nums[largest] > nums[index]) ? largest : index;
        // 2.index赋值为最大值的下标，如果index本身就是最大值，
        // 则说明该节点下的已经是堆结构，不用继续
        if(largest == index) break;
        swap(nums[largest], nums[index]);
        index = largest;
        left = 2 * index + 1;
    }
}

void heapSort(vector<int>& nums){
   // 1.一个一个插入节点，每次插入一个都要调整成为大根堆
   for(int i = 0; i < nums.size(); i++){
       heapInsert(nums, i);
   }
   print(nums, 0, nums.size() - 1);
   // 头尾节点交换，因为此刻头结点是最大值，交换后断连最后一个节点
   // 然后循环，将每一部分未断连的部分进行重新堆化，再交换，再断连
   // 这样断连的部分就是有序的
   int heapSize = nums.size();
   swap(nums[0], nums[--heapSize]);
   while(heapSize){
       heapify(nums, 0, heapSize);
       print(nums, 0, heapSize);
       swap(nums[0], nums[--heapSize]);
   }
}

void print(vector<int>& nums, int start, int end){
    if(start > end){
        cout << "index error" << endl;
        return;
    }
    cout << endl;
    for(int i = start; i <= end; i++){
        cout << nums[i] << '\t';
    }
    cout << endl;
}

```

