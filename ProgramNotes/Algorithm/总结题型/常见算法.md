# 算法

[TOC]



## 排序算法         

### 1、冒泡算法

稳定

```c++
#include <iostream>
#include <vector>
#include <algorithm> 
#define Num 100 
using namespace std;

//产生随机数 
void rand_nums(vector<int> &temp)
{
    for (int i = 0; i < Num; ++i) temp.push_back(i + 1);
    random_shuffle(temp.begin(), temp.end());
}

void print(vector<int> &nums){
	for(int i = 0; i<nums.size(); i++){
		cout << nums[i] << " ";
		if((i+1)%10 == 0) cout << "\n";
	}
}

// 冒泡算法
void bubble_sort(vector<int> &nums){
	int flag = 1;
	for(int i=0; i<nums.size() && flag; i++){
		for(int j=nums.size()-1; j>i; j--){
			flag = 0; // 发生交换会置1
			if(nums[j] > nums[j-1]){
				swap(nums[j], nums[j-1]);
				flag = 1;
			}
		}
	}
}

int main(){
	vector<int> nums;
	rand_nums(nums);
	print(nums);
	cout << endl;
	bubble_sort(nums);
	print(nums);
	return 0;
} 
```



### 2、选择排序

不稳定

举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法

```c++
#include <iostream>
#include <vector>
#include <algorithm> 
#define Num 100 
using namespace std;

//产生随机数 
void rand_nums(vector<int> &temp)
{
    for (int i = 0; i < Num; ++i) temp.push_back(i + 1);
    random_shuffle(temp.begin(), temp.end());
}

void print(vector<int> &nums){
	for(int i = 0; i<nums.size(); i++){
		cout << nums[i] << " ";
		if((i+1)%10 == 0) cout << "\n";
	}
}

// 选择排序 
void choose_sort(vector<int> &nums){
	for(int i = 0; i<nums.size(); i++){ //遍历每一个数 
		int maxIndex = i;
		for(int j = i+1; j<nums.size(); j++){ //找最大值的下标 
			if(nums[j] > nums[maxIndex]) maxIndex = j;
		}
		swap(nums[i], nums[maxIndex]); //将最大值交换到i的位置 ，完成了最大值选择到前面 
	}
}

int main(){
	vector<int> nums;
	rand_nums(nums);
	
	print(nums);
	cout << endl;
	
	choose_sort(nums);
	
	print(nums);
	return 0;
} 
```



### 3、插入排序

稳定

```c++
#include <iostream>
#include <vector>
#include <algorithm> 
#define Num 100 
using namespace std;

//产生随机数 
void rand_nums(vector<int> &temp)
{
    for (int i = 0; i < Num; ++i) temp.push_back(i + 1);
    random_shuffle(temp.begin(), temp.end());
}

void print(vector<int> &nums){
	for(int i = 0; i<nums.size(); i++){
		cout << nums[i] << " ";
		if((i+1)%10 == 0) cout << "\n";
	}
}

// 插入排序 
void insert_sort(vector<int> &nums){
	for(int i = 1; i<nums.size(); i++){
		for(int j = i-1; j>=0; j--){ // 将i之前的数都比较一遍，并把更大的数放到前面 
			if(nums[j+1] > nums[j]){
				swap(nums[j], nums[j+1]); 
			}
		}
	}
}

int main(){
	vector<int> nums;
	rand_nums(nums);
	
	print(nums);
	cout << endl;
	
	insert_sort(nums);
	print(nums);
	
	return 0;
} 
```



### 4、归并排序

稳定

注意的点有：

1. 二分的时候，返回条件 `l == r`
2. 二分区间：`[l, mid]、[mid + 1, r]`，就是连续的`[l, r]`都被二分了
3. 合并的时候传入的范围参数`[l, mid, r]`

V1--易理解版本，每次合并创建一个辅助空间

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void mergeSort(vector<int>& nums, int l, int r);
void print(vector<int>& nums, int start, int end);
void merge(vector<int>& nums, int l, int mid, int r);

// 归并排序
void mergeSort(vector<int>& nums, int l, int r){
    if(l == r) return;
    int mid = l + (r - l) / 2;
    mergeSort(nums, l, mid); // 左段有序
    mergeSort(nums, mid + 1, r); // 右段有序
    merge(nums, l, mid, r); // 合并左右
}
// 合并过程
void merge(vector<int>& nums, int l, int mid, int r){ // 归并过程
    vector<int> help(r - l + 1); // 辅助数组
    int p1 = l, p2 = mid + 1; // 两个组：p1∈[l, mid]，p2∈[mid + 1, r]
    int i = 0; // i划过help数组的下标
    // 1.哪个小拷贝哪个
    while(p1 <= mid && p2 <= r){
        help[i++] = (nums[p1] <= nums[p2]) ? nums[p1++] : nums[p2++]; 
    }
    // 2.还有可能一个组没拷贝完，也要添加到help后面
    while(p1 <= mid) help[i++] = nums[p1++];
    while(p2 <= r) help[i++] = nums[p2++];
    // 3.拷贝回原数组
    for(int i = 0; i < help.size(); i++){
        nums[l + i] = help[i];
    }
}
// 打印nums,限定范围[L, R]
void print(vector<int>& nums, int start, int end){
    if(start > end){
        cout << "index error" << endl;
        return;
    }
    cout << endl;
    for(int i = start; i <= end; i++){
        cout << nums[i] << '\t';
    }
    cout << endl;
}

int main(){
    vector<int> nums = {4, 2, 1, 5, 9, 6, 7, 10, 3, 8};
    print(nums, 0, nums.size() - 1);
    mergeSort(nums, 0, nums.size() - 1);
    print(nums, 0, nums.size() - 1);
    return 0;
}
```

第二种写法，不用频繁创建辅助数组，节省空间，**推荐**！

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        if(nums.size() < 2) return nums;
        help.reserve(nums.size()); // 分配nums大小的空间
        mergeSort(nums, 0, nums.size() - 1);
        return nums;
    }
private:
    vector<int> help; // 就用一个辅助空间
    void mergeSort(vector<int>& nums, int l, int r){
        if(l == r) return;
        int mid = l + (r - l) / 2;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        merge(nums, l, mid, r);
    }
    void merge(vector<int>& nums, int l, int mid, int r){
        int p1 = l, p2 = mid + 1;
        int index = l;
        while(p1 <= mid && p2 <= r){
            help[index++] = (nums[p1] <= nums[p2]) ? nums[p1++] : nums[p2++];
        }
        while(p1 <= mid) help[index++] = nums[p1++];
        while(p2 <= r) help[index++] = nums[p2++];
        for(int i = l; i <= r; i++){
            nums[i] = help[i];
        }
    }
};
```



### 5、快速排序

不稳定

当每次选择的元素为最大值或者最小值进行划分时，就会退化为O（N2）

比如1 2 3 4 5 6 7 8 9，

选择1划分：右指针一直往左移，直到1的位置，划过8个位置

选择2划分：右指针一直往左移，直到2的位置，划过7个位置

选择3划分：...

选择使用随机值

推荐写法，随机值作为划分值，时间复杂度O(NlogN)，空间复杂度O（logN）

```c++
void quickSort(vector<int>& nums, int l, int r){
        if(l >= r) return;
        int i = l, j = r;
    	// 随机选择一个值，跟l位置交换，用nums[l]来划分
        int randIndex = rand()%(r - l + 1) + l;
        swap(nums[l], nums[randIndex]); 
        int& p = nums[l];
        while(i < j){
            while(nums[j] >= p && i < j) j--;
            while(nums[i] <= p && i < j) i++;
            swap(nums[i], nums[j]);
        }
        swap(nums[i], p);
        quickSort(nums, l, i - 1);
        quickSort(nums,  i + 1, r);
    }
```

快排1.0，时间复杂度O(N2)

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void quickSort(vector<int>& nums, int l, int r);
void print(vector<int>& nums, int start, int end);

int main(){
    vector<int> nums = {4, 2, 1, 5, 9, 6, 7, 10, 3, 8};
    print(nums, 0, nums.size() - 1);
    quickSort(nums, 0, nums.size() - 1);
    print(nums, 0, nums.size() - 1);
    return 0;
}

// 快速排序
void quickSort(vector<int>& nums, int l, int r){
    if(l > r) return;
    int i = l, j = r;
    // 将 [l, r]与哨兵nums[l]大小相比进行划分，成两组
    while(i < j){
        while(i < j && nums[j] > nums[l]) j--; // 从右往左，大于哨兵nums[l]就j--
        while(i < j && nums[i] < nums[l]) i++; // 从左往右，小于哨兵nums[l]就i++
        swap(nums[i], nums[j]); // 此时nums[i] >= nums[l], nums[j] <= nums[l]
    }
    // 以i为分界线，将哨兵nums[l]放到分界线处
    swap(nums[l], nums[i]);
    // 以i为分界线，[l, i - 1]为小于nums[l], [i + 1, r]为大于nums[l]
    quickSort(nums, l, i - 1);
    quickSort(nums, i + 1, r);
}



void print(vector<int>& nums, int start, int end){
    if(start > end){
        cout << "index error" << endl;
        return;
    }
    cout << endl;
    for(int i = start; i <= end; i++){
        cout << nums[i] << '\t';
    }
    cout << endl;
}

```

左神写法：

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        if(nums.size() < 2) return nums;
        quickSort(nums, 0, nums.size()-1);
        return nums;
    }
private:
    void quickSort(vector<int>& nums, int L, int R){
        if(L < R){
            // 取得[a,b)的随机整数：rand()%(b-a)+a；
            // 取得[a,b]的随机整数：rand()%(b-a+1)+a； 
            int randNum = L + (rand()%(R-L+1));
            //swap_vec(nums, , R);  //将nums中的随机一个数放到最后一个位置 R 
            swap(nums[randNum], nums[R]);
            // 这一步就是将nums[L,R]做partition,partition过程：nums[R]为划分值，对nums[L...R-1]划分 
            vector<int> pos =  partition(nums, L, R); // 返回 < == > 这个范围最左\最右边界 
            quickSort(nums, L, pos[0]-1); // <区 
            quickSort(nums, pos[1]+1, R); // >区 
        }
    }
    vector<int> partition(vector<int>& nums, int L, int R) {
        int index = L;
        // 这里相当于将nums[L...R-1] 玩partion, 最后一个位置 R 是不参与，
        // 所以后面进行swap(nums,R, more) 
        int less = L - 1;
        int more = R;  
        int p = nums[R]; //以最后一个数作为划分值 p 
        while (index < more) {
            if (nums[index] < p) {
                swap(nums[index++], nums[++less]);
            }
            else if (nums[index] > p) {
                swap(nums[index], nums[--more]);
            }
            else index++;
        }
        swap(nums[R], nums[more]);  
        return vector<int> {less + 1, more}; //这个表示 ==p 的区域 
    } 
};
```



### 6、堆排序

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void heapInsert(vector<int>& nums, int index);
void heapify(vector<int>& nums, int index, int heapSize);
void heapSort(vector<int>& nums);
void print(vector<int>& nums, int start, int end);

int main(){
    vector<int> nums = {4, 2, 1, 5, 9, 6, 7, 10, 3, 8};
    print(nums, 0, nums.size() - 1);
    heapSort(nums);
    print(nums, 0, nums.size() - 1);
    return 0;
}


void heapInsert(vector<int>& nums, int index){ // 调整成大根堆
   // 给你一个节点下标是index，那么它的父节点是 (index - 1) / 2
   // 这一部分就是将父节点 调节成 大根堆
   while(nums[index] > nums[(index - 1) / 2]){
       swap(nums[index], nums[(index - 1) / 2]);
       index = (index - 1) / 2;
   }
}

void heapify(vector<int>& nums, int index, int heapSize){
    int left = 2 * index + 1;
    while(left < heapSize){
        // 1.父节点index、左右孩子的最大值
        int largest = (left + 1 < heapSize && nums[left + 1] > nums[left]) ? left + 1 : left;
        largest = (nums[largest] > nums[index]) ? largest : index;
        // 2.index赋值为最大值的下标，如果index本身就是最大值，
        // 则说明该节点下的已经是堆结构，不用继续
        if(largest == index) break;
        swap(nums[largest], nums[index]);
        index = largest;
        left = 2 * index + 1;
    }
}

void heapSort(vector<int>& nums){
   // 1.一个一个插入节点，每次插入一个都要调整成为大根堆
   for(int i = 0; i < nums.size(); i++){
       heapInsert(nums, i);
   }
    /* 如果是给的一个完整的数组，不是一个一个插入，那么这种，直接heapify的过程调整成大根堆会更快！注意传入的第三个参数是长度，而不是下标最大值！
    for(int i = nums.size() - 1; i >= 0; i--){
            heapify(nums, i, nums.size());
     }
    */
   print(nums, 0, nums.size() - 1);
   // 头尾节点交换，因为此刻头结点是最大值，交换后断连最后一个节点
   // 然后循环，将每一部分未断连的部分进行重新堆化，再交换，再断连
   // 这样断连的部分就是有序的
   int heapSize = nums.size();
   swap(nums[0], nums[--heapSize]);
   while(heapSize){
       heapify(nums, 0, heapSize);
       print(nums, 0, heapSize);
       swap(nums[0], nums[--heapSize]);
   }
}

void print(vector<int>& nums, int start, int end){
    if(start > end){
        cout << "index error" << endl;
        return;
    }
    cout << endl;
    for(int i = start; i <= end; i++){
        cout << nums[i] << '\t';
    }
    cout << endl;
}

```

