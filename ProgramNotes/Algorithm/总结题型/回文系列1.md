# 回文系列

### 1.[234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

![image-20210611102604429](回文系列1.assets/image-20210611102604429.png)

**一般回文系列、反转之类的题都可以考虑用栈来做！**

#### 解法1：快慢指针 

本题最优解法。

快慢指针找中点，然后在中间反转链表，注意事项见注释。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
       if(head == nullptr || head->next == nullptr) return true;
       ListNode* slow = head, *fast = head, *pre;
       // 找中点
       while(fast && fast->next){
           pre = slow;
           slow = slow->next;
           fast = fast->next->next;
       }
        pre->next = nullptr; //前后断开
        // 反转后一段链表
        ListNode* cur = slow; 
        ListNode* pre1 = nullptr;
        while(cur){
            ListNode* tmp = cur->next;
            cur->next = pre1;
            pre1 = cur;
            cur = tmp;
        }
        // pre1为后半段链表头结点
        ListNode* c1 = pre1;
        ListNode* c2 = head;
        while(c1 && c2){
            if(c1->val != c2->val) return false; // 判断条件不能是节点，而是节点值！
            c1 = c1->next;
            c2 = c2->next;
        }
        return true;
    }
};
```

