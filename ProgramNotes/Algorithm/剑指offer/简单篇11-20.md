# 简单篇

## 11-20

### 11.[剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

#### 解法1：新建链表串联两个链表节点

1.当两个链表都不为空的时候，head的下一个指针指向==节点值更小==的节点

2.当两个链表不为空遍历完，head的下一个指针该指向哪个节点？

当然是优先指向非空的节点！！！怎么判断非空呢？

只需要判断其中一条链表是否为空即可！比如链表1为空，那么就==优先==指向链表2

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* head = new ListNode(0);
        ListNode* res = head;
        while(l1 != nullptr && l2 != nullptr){
            // head->next优先指向节点值更小的点
            if(l1->val < l2->val){  
                head->next = l1;
                l1 = l1->next;
            }else{
                head->next = l2;
                l2 = l2->next;
            }
            head = head->next;
        }
        // 假如l1 或者 l2 有一个还未空，则head的下一个应该指向非空的那个
        head->next = (l1 == nullptr) ? l2 : l1;
        return res->next;
    }
};
```

#### 解法2：递归

这里返回条件比较难想，可以从重叠子问题思想来思考，即选好了一个小的节点，那么下一次要合并的是不是它的下一个节点跟另一个链表的合并问题？

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1 == nullptr) return l2;
        if(l2 == nullptr) return l1;
        if(l1->val < l2->val){
            // 让更小的成为头节点，并让更小的下一个节点跟另一个链表去合并
            l1->next = mergeTwoLists(l1->next, l2); 
            return l1;  // 返回更小的节点
        }else{
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};
```

